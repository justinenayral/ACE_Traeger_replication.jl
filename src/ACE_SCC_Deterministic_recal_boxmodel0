# ACE_SCC_Deterministic.jl
# Last edited CT 2021 (created CT 2014 merging earlier files)
#
# Calculates deterministic shadow values and SCC for ACE model
# - calls TMDynamics.jl to initialize Climate Dynamics
# - if using boxmodel calls Joos_decay_boxes.jl 
# - if using population weighting with time preference recalibration calls
#      CalibrateBetaPopulation.jl
#

using Optim

function squeeze(M::Vector{Float64})
    return dropdims(M,dims=tuple(findall(size(M).==1)...))
  end


# MAIN SETTINGS
include("DamageSterner.jl")
include("TMDynamics.jl")


# DISCOUNT RATE for exogenous discounting scenario (first scenario). Second scenario endogenously determined by IMF calibration
# param.rho_discount_annual_exo=0.0139; # IMF calibrated (same as endogenously calibrated in IMF scenario)
param["rho_discount_annual_exo"] = 0.005   # Median of Drupp et al. (2018) survey 
# param.rho_discount_annual_exo=0.001  # Low discounting scenario 

# DAMAGE SPECIFICATION
damages = 1 # = 1 Nordhaus damages
             # = 2 HSP damages

# CLIMATE MODEL SPECIFICATIONS
boxmodel = 0 # =0 use DICE 2013 carbon cycle
# boxmodel = 1 # =1 use Joos 2013 box model, 

# POPULATION WEIGHTING:
population = 1      # =1 UN population scenario until 2100, =0 off
pop_recalibrate = 1 # =1 recalibrate discount rate (prints additional output at the end), = 0 off

# USE GDP vs CONSUMPTION-based calibration, i.e., Y versus C/(1-beta*kappa). Eqn (13) and Proposition 4.
# Makes a difference if not using calibrated time preference (kappa_calib ~NOT= kappa)
use_beta_invrate_parity = false
# = true: use original formula based on Y. If discount rate exogenous: Do not match empirical investment rate
# = false: use C/(1-beta*kapp) formula. If discount rate exogenous: Taking beta and kappa as relevant input
#          recommended in particular for exogenous time preference and timestep < 10 years scenarios
# Note: Table 1 uses use_beta_invrate_parity = false

# KAPA - PRODUCTIVITY 
param["kappa"] = 0.3          # used to evaluate SCC (=.3 for base, =.4 for "productivity" scenarios)
param["kappa_calib"] = 0.3    # used to calibrate time preference (for "recal" scenarios also update param.kappa_calib)
# Notes: Base scenario uses 0.3 for both parameters
#        Using higher productivity kappa=0.4 
#        - should be paired with use_beta_invrate_parity=false to use consumption based evaluation
#        - can be paired with either of
#          param.kappa_calib=0.3;   # keeps calibrated time preference the same
#          param.kappa_calib=0.4;   # also updates calibration of time preference ("recal" scenario)

# Exchange rate for Euro cents per liter:
EURperUSD = 1 / 1.1348  # average 2020 on Nov 30st 2020

# DAMAGES 
switch_damvar = 0  # =0: base scenario using calibrated damage coefficients
# =1 Increases damage semi-elasticity by factor dam_fact
    # dam_fact=1.1 ;  # multiplies param.xi0 (which below is fitted to Nordhaus)
# =2 overwrites param.xi0 by parameter value param.xi0_eco
    # param.xi0_exo =  ;


for jj in 1:length(list["damages"])
    
    if damages == 1
        matchtemp = 2.5  # DICE std: 2.5 - defines temperature at which matching DICE damages
        a_Nord = 0.0028  # DICE 2007  % BASE SCENARIO together with matchtemp = 2.5
        #a_Nord = 0.00267  # DICE 2013R
        #a_Nord = 0.00236  # DICE 2016
    elseif damages == 2
        # Calibration damages to HSP scenario (uncomment next two lines):
        matchtemp = 3   # for Howard & Sterner matched at 3C  % HSP Variation
        a_Nord = 0.01145  # Howard & Sterner (2017)             % HSP Variation
    else
        error("You have to select damages = 1 (Nordhaus) or damages = 2 (HSP)")
    end
       
    # Set timestep (has to corresponds to TMDynamics, here 10 years)
    param["timestep"] = 10 # in years

    # IMF forecast data 
    param["Y20"]=130.186703e12; # IMF Oct 2020 forecast for 2020 in PPP (trillion=10^12)
    # Investment rate: 
    param["InvRate20"]=0.26108	; # IMF 2020 investment rate estimate, forecasted in Oct 2020
    # Implied factors:
    param["beta_exo"]=exp(-param["rho_discount_annual_exo"]*param["timestep"]);


    # Solve for damage coefficient
    param["xi0"] = xi0DICE([0.0], a_Nord, 2.5)
    println("Using cs=$(cs), xi1=$(param["xi"][1]), matching xi0=$(param["xi0"])")

    if switch_damvar == 1
        param["xi0"] *= dam_fact
        println("!! Changing damages by factor $(dam_fact)")
    elseif switch_damvar == 2
        param["xi0"] = param["xi0_exo"]
        println("!! Changing damages parameter $(param["xi0"]) to exogenously given $(param["xi0"]) probably for deterministic base value in stochastic run...")
    end

# Population input
    if population == 1 # load UN population data, 2020-2100 in 5 year steps
        pop_5year = [7794799, 8184437,	8548487, 8887524, 9198847, 9481803, 9735034, 9958099,	10151470, 10317879, 10459240, 10577288, 10673904, 10750662, 10809892, 10851860, 10875394]
        pop_decadal = pop_5year[1:2:17] # first 2020, last 2100
        pop = pop_decadal
        if param["timestep"] != 10
            error("population uses decadal time step, different from model time step")
        end 
    end

# Prepare for calculating deterministic shadow values
# Calculate rho and beta for endogenous time preference calibration
    beta_implied20 = param["InvRate20"] / param["kappa_calib"]
    rho_implied20 = -1 / param["timestep"] * log(beta_implied20)

# Arranging discount parameters into a list for looping
# Eliminated outdated world output calibration as list entry 2 (thus 2 is skipped in for loop below)
    param["beta"] = zeros(3)
    param["beta"][1] = param["beta_exo"]
    param["beta"][3] = beta_implied20
    param["rho"] = zeros(3)
    for i in 1:3
        param["rho"][i] = -1 / param["timestep"] * log(param["beta"][i]) # putting rho's into list for loop
    end

    println("Matched quadratic damage coefficient of $a_Nord at $matchtemp degree Celsius")
    println("DETERMINISTIC MODEL OUTPUT (for different calibrations): ")
    
        phi = Dict()
        phi_NoTempLag = Dict()
        phi["k"] = zeros(3)
        phi["M"] = zeros(3,3)
        phi["M_edec"] = zeros(3,3)
        phi_NoTempLag["M"] = zeros(3,3)
        PsiTau_scen = zeros(3,3,3)
        PsiM_scen = zeros(3,3,3)
        phi["tau"] = zeros(3,3)
        phi["M_immediate_forc"] = zeros(3,3)
        phi["M_immediate_forc_tot"] = zeros(3,3)
        phi["k_pop"] = zeros(3,9)
        phi["tau_pop"] = zeros(3,9,3)
        phi["M_pop"] = zeros(3,9,3)
        phi["M_pop_help"] = zeros(3,9,3)
        phi_NoTempLag["tau_pop"] = zeros(3,9,3)
        phi_NoTempLag["M_pop"] = zeros(3,9,3)
        phi_NoTempLag["M_pop_help"] = zeros(3,9,3)
        x = zeros(3)
        x_pop = zeros(3,8)
        C = zeros(3)
        SCC_inC = zeros(3,3)
        SCC_inC_immediate_forc = zeros(3,3)
        SCC_inCO2_immediate_forc = zeros(3,3)
        SCC_inCO2_immediate_forc_tot = zeros(3,3)
        SCC_inC_immediate_forc_tot = zeros(3,3)
        SCC_gall = zeros(3)
        SCC_inCO2_15 = zeros(3,3)
        SCC_lit = zeros(3)
        SCC_inC_NoTempLag = zeros(3,3)
        SCC_inCO2_NoTempLag = zeros(3,3)
        SCC_inC_edec = zeros(3,3) 
        SCC_inCO2_15_edec = zeros(3,3) 
        SCC_inC_direct = []
        SCC_inC_pop = zeros(3,3) 
        SCC_inCO2_pop = zeros(3,3) 
        SCC_inC_NoTempLag_pop = zeros(3,3) 
        SCC_inCO2_NoTempLag_pop = zeros(3,3) 
        SCC_gall_pop = zeros(3) 
        SCC_lit_pop = zeros(3) 

    for i in (1,3)
    # STATIONARY CASE (no population weighting scenario)
    # Calculate phi["M"]
    phi["k"][i] = param["kappa"] / (1 - param["kappa"] * param["beta"][i])
    # Below "Psi_sigma" matrix: (1-beta sigma)^-1
    PsiTau = inv(diagm(ones(3)) - param["beta"][i] * TempMatrix)
    PsiTau_scen[i, :, :] = PsiTau
    phi["tau"][i, :] = -param["xi0"] * (1 + param["beta"][i] * phi["k"][i]) * PsiTau[1, :]
    # Below "Psi_Phi" matrix: (1-beta Phi)^-1
    PsiM = inv(diagm(ones(3)) - param["beta"][i] * CarbonMatrix) 
    PsiM_scen[i, :, :] = PsiM


    phi["M"][i, :] = param["beta"][i] * sigma_temp_up[1] * phi["tau"][i, 1] / Mpre * PsiM[1, :]
    phi["M_edec"][i, :] = param["beta"][i] * sigma_temp_up[1] * phi["tau"][i, 1] / Mpre * PsiM * CarbonMatrix[:, 1]
    # w/o temp delay replace sigma_forc*phi.tau by - xi0 (1_beta*phi.k):
    phi_NoTempLag["M"][i, :] = param["beta"][i] * 1 * (-param["xi0"]) * (1 + param["beta"][i] * phi["k"][i]) * 1 / Mpre * PsiM[1, :]
    # Timing where T_t+1 is forced by M_t+1: 
    phi["M_immediate_forc"][i, :] = param["beta"][i] * sigma_temp_up[1] * phi["tau"][i, 1] / Mpre * CarbonMatrix[1, :]' * PsiM[:,:]
    phi["M_immediate_forc_tot"][i, :] = phi["M_immediate_forc"][i, :] .+ sigma_temp_up[1] / Mpre * phi["tau"][i, 1]
    

    if population == 1
        growth_pop_factor = pop[2:end] ./ pop[1:end-1]
        growth_pop_rate = growth_pop_factor .- 1
        
        # Initialize year 2100
        phi["k_pop"][i, length(growth_pop_factor) + 1, :] .= phi["k"][i]
        phi["tau_pop"][i, length(growth_pop_factor) + 1, :] .= phi["tau"][i, :]
        phi_NoTempLag["tau_pop"][i, length(growth_pop_factor) + 1, :] .= phi["tau"][i, :] # Initialization doesn't matter for phi.tau (overwrite)
        

            # Initialize shadow value with 2100 stationary values
            phi["M_pop_help"][i, length(growth_pop_factor) + 1, :] .= phi["M"][i, :]
            phi["M_pop"][i, length(growth_pop_factor) + 1, :] .= phi["M_pop_help"][i, length(growth_pop_factor) + 1, :]
            phi_NoTempLag["M_pop_help"][i, length(growth_pop_factor) + 1, :] .= phi_NoTempLag["M"][i, :]
            phi_NoTempLag["M_pop"][i, length(growth_pop_factor) + 1, :] .= phi_NoTempLag["M_pop_help"][i, length(growth_pop_factor) + 1, :]
            Vec = [1; zeros(2)] # only atm carbon contributes forcing
        
    
        # Loop works backwards taking 2100 as eql values calculated above w/o population growth
        for lind = length(growth_pop_factor):-1:1
            phi["k_pop"][i, lind, 1] = param["kappa"] + param["beta"][i] * growth_pop_factor[lind] * param["kappa"] * phi["k_pop"][i, lind+1, 1]
            phi["tau_pop"][i, lind, :] = param["beta"][i] * growth_pop_factor[lind] * transpose(squeeze(phi["tau_pop"][i, lind+1, :])) * TempMatrix -
                                        reshape([(1 + param["beta"][i] * growth_pop_factor[lind] * phi["k_pop"][i, lind+1, 1]) * param["xi0"];
                                        zeros(2)], (3,1))'
            phi_NoTempLag["tau_pop"][i, lind, :] .= -[(1 + param["beta"][i] * growth_pop_factor[lind] * phi["k_pop"][i, lind+1, 1]) * param["xi0"];
                                                    zeros(2)]
            phi["M_pop_help"][i, lind, :] .= param["beta"][i] * growth_pop_factor[lind] * phi["tau_pop"][i, lind+1, 1] * sigma_temp_up[1] / Mpre * Vec +
                                           reshape(param["beta"][i] * growth_pop_factor[lind] * transpose(squeeze(phi["M_pop_help"][i, lind+1, :])) * CarbonMatrix, (3,1))
            phi_NoTempLag["M_pop_help"][i, lind, :] .= param["beta"][i] * growth_pop_factor[lind] * phi_NoTempLag["tau_pop"][i, lind+1, 1] / Mpre * Vec +
                                                     reshape(param["beta"][i] * growth_pop_factor[lind] * transpose(squeeze(phi_NoTempLag["M_pop_help"][i, lind+1, :])) * CarbonMatrix, (3,1))
            x_pop[i, lind] = 1 / (1 + param["beta"][i] * growth_pop_factor[lind] * phi["k_pop"][i, lind, 1])
            
            phi["M_pop"][i, lind, :] .= phi["M_pop_help"][i, lind, :]
            phi_NoTempLag["M_pop"][i, lind, :] .= phi_NoTempLag["M_pop_help"][i, lind, :]
        end
    end
    
    function CalibrateBetaPopulation(param, phi, TempMatrix, sigma_temp_up, CarbonMatrix, Mpre, growth_pop_factor, beta_cali)
        i = 3  # only running recalibration for third scenario
    
        # Recalculate equilibrium shadow values for 2100
        phi["k_cali"] = param["kappa"] / (1 - param["kappa"] * beta_cali)
        PsiTau = inv(diag(ones(3)) - beta_cali * TempMatrix)
        phi["tau_cali"] = -param["xi0"] * (1 + beta_cali * phi["k_cali"]) * PsiTau[1, :]
        PsiM = inv(diag(ones(3)) - beta_cali * CarbonMatrix)
        
        if param["boxmodel"] != 1
            phi["M_cali"] = beta_cali * sigma_temp_up[1] * phi.tau_cali[1] / Mpre * PsiM[1, :]  # for ppm
            phi_NoTempLag["M_cali"] = beta_cali * 1 * (-param["xi0"]) * (1 + beta_cali * phi["k_cali"]) * 1 / Mpre * PsiM[1, :]  # for ppm
            Vec = [1; zeros(2)]  # only atm carbon contributes forcing (see recursive calucation of phi_M)
        end
    
        # Loop back from 2100 under population growth
        # Initialization of variables with stationary values:
        phi["k_pop_cali"][length(growth_pop_factor) + 1] = phi["k_cali"]
        phi["tau_pop_cali"][length(growth_pop_factor) + 1, :] = phi["tau_cali"]
        phi_NoTempLag["tau_pop_cali"][length(growth_pop_factor) + 1, :] = phi["tau_cali"]  # Initialization doesn't matter for phi.tau (overwritte)
        phi["M_pop_cali"][length(growth_pop_factor) + 1, :] = phi["M_cali"]
        phi_NoTempLag["M_pop_cali"][length(growth_pop_factor) + 1, :] = phi_NoTempLag["M_cali"]
    
        for lind in length(growth_pop_factor):-1:1
            phi["k_pop_cali"][lind] = param["kappa"] + beta_cali
        end
    end

    if i == 3 && population == 1 && pop_recalibrate == 1
        param["boxmodel"] = boxmodel   # Need to pass to function below
        if boxmodel == 1
            param["CarbonWeights"] = CarbonWeights  # Need to pass it to function below
        end
        xl = 0
        xh = 1  # Upper bound on discount factor
        Acons = []  # [1 TrExi.Yprei; 0 1]; Acons*q < bcons; 1*q1 + YPre*q2 < Ypre
        bcons = []  # [TrExi.Yprei; TrExi.Psii];
        # Optimization:
        param["popsim"] = 0  # turning off global phi for optimization
        beta_start = param["beta"][3]
        optim_handle = beta_cali -> (1 - param["InvRate20"] - CalibrateBetaPopulation(param, phi, TempMatrix, sigma_temp_up, CarbonMatrix, Mpre, growth_pop_factor, beta_cali))^2
        beta_recal = optimize(optim_handle, beta_start, Acons, bcons, xl, xh)
        consrate_pop = CalibrateBetaPopulation(param, phi, TempMatrix, sigma_temp_up, CarbonMatrix, Mpre, growth_pop_factor, beta_recal)
    end
    
  
    
        if use_beta_invrate_parity == 1
            x[i] = 1 - param["beta"][i] * param["kappa"]  # Consumption rate is based on discount rate calibration
        else
            x[i] = 1 - param["InvRate20"]
        end
        

        C[i] = param["Y20"] * x[i] * param["timestep"]  # Consumption level is rate times actual consumption
        param["Y"]=param["Y20"]
        SCC_inC[i, :] = -phi["M"][i, :] * C[i] / 10^9  # /10^9 transforms per Gt to per ton
        SCC_inCO2_15[i, :] = SCC_inC[i, :] / (44 / 12)
    

    # Added in August 21 for timing with M_t+1 in T_t+1
        SCC_inC_immediate_forc[i, :] = -phi["M_immediate_forc"][i, :] * C[i] / 10^9  # /10^9 transforms per Gt to per ton
        SCC_inCO2_immediate_forc[i, :] = SCC_inC_immediate_forc[i, :] / (44 / 12)
    
        SCC_inC_immediate_forc_tot[i, :] = -phi["M_immediate_forc_tot"][i, :] * C[i] / 10^9  # /10^9 transforms per Gt to per ton
        SCC_inCO2_immediate_forc_tot[i, :] = SCC_inC_immediate_forc_tot[i, :] / (44 / 12)
    
        SCC_inC_edec[i, :] = -phi["M_edec"][i, :] * C[i] / 1e9  # edec = emission decay already over the course of the period
        SCC_inCO2_15_edec[i, :] = SCC_inC_edec[i, :] / (44 / 12)
        SCC_gall[i, 1] = SCC_inCO2_15[i, 1] * 8.78 / 1000 * 100  # 8.78 kgCO2/gallon (and ton->kg, and USD->cent)
        SCC_lit[i, 1] = SCC_gall[i] / 3.78541 * EURperUSD  # 1 gallon = 3.78541 liter

    # Cutting out temperature delay would result in SCC
        SCC_inC_NoTempLag[i, :] = -phi_NoTempLag["M"][i, :] * C[i] / 10^9
        SCC_inCO2_NoTempLag[i, :] .= SCC_inC_NoTempLag[i] / (44 / 12)


        if population == 1
            # SCC calculation based on population weighting
            SCC_inC_pop[i,:] = -phi["M_pop"][i,1,:] * C[i] / 10^9  # where second position is year 2020
            SCC_inCO2_pop[i,:] = SCC_inC_pop[i,:] / (44/12)
        
            # Cutting out temperature delay would result in SCC
            SCC_inC_NoTempLag_pop[i,:] = -phi_NoTempLag["M_pop"][i,1,:] * C[i] / 10^9  # where second position is year 2020
            SCC_inCO2_NoTempLag_pop[i,:] = SCC_inC_NoTempLag_pop[i,:] / (44/12)
        
            # Convert SCC to gallons and liters
            SCC_gall_pop[i,1] = SCC_inCO2_pop[i,1] * 8.78 / 1000 * 100  # 8.78 kgCO2/gallon (and ton->kg, and USD->cent)
            SCC_lit_pop[i,1] = SCC_gall_pop[i,1] / 3.78541 * EURperUSD  # 1 gallon = 3.78541 liter

        end
        

    # Decomposition terms:
    println(" Case: ", scenario[i, :], " - implied annual rho ", round(param["rho"][i] * 100, digits=2), "%")
    println("  Varphi_k (utility shadow value of capital) ", round(phi["k"][i], digits=5))
    # Next two lines merged back in from older version that was probably fixed in parallel:
    println("  Varphi_tau (utility shadow value generalized temperature) ", round.(phi["tau"][i, :], digits=5))
    println("  Varphi_M (utility shadow value carbon) ", round.(phi["M"][i, :], digits=5))
    println(" SCC year 2020: ", round(SCC_inC[i], digits=5), " & in CO2: ", round(SCC_inC[i] / (44 / 12), digits=5), ". Decomposing: ")
    println("    beta 10Y/Mpre= ", round(param["beta"][i] * 10 * param["Y"] / (Mpre * 10^9), digits=5), " & in CO2: ", round(param["beta"][i] * param["Y"] / (Mpre * 10^9) / (44 / 12) * 10, digits=5), ".")
    println("    damage parameter xi0 ", round(param["xi0"], digits=5))
    println("    beta 10Y/Mpre*xi0= ", round(param["beta"][i] * 10 * param["Y"] / (Mpre * 10^9) * param["xi0"], digits=5), " & in CO2: ", round(param["beta"][i] * param["Y"] / (Mpre * 10^9) * param["xi0"] / (44 / 12) * 10, digits=5))
    println("   Base: beta 10C/(1-beta*kappa)/Mpre*xi0= ", round(param["beta"][i] * C[i] / (1 - param["beta"][i] * param["kappa"]) / (Mpre * 10^9) * param["xi0"], digits=5), " & in CO2: ", round(param["beta"][i] * C[i] / (1 - param["beta"][i] * param["kappa"]) / (Mpre * 10^9) * param["xi0"] / (44 / 12), digits=5))
    println("    sigma^forc ", round(sigma_temp_up[1], digits=5))
    println("    PsiM_{1,1} contribution ", round(PsiM[1, 1], digits=5))
    println("    PsiTau_{1,1} contribution ", round(PsiTau[1, 1], digits=5))
    println(" SCC w/o temp delay (cut sigma Matrix and sig^forc): ", round(SCC_inC_NoTempLag[i], digits=5), " & in CO2 : ", round(SCC_inC_NoTempLag[i] / (44 / 12), digits=5))
    println(" PERCENT of orignal tax if ignoring carbon dynamics ", round(100 / (PsiM[1, 1]), digits=5))
    println("")

    println("Inv rate ", round(1 - x[1], digits=3), ";  rho exog,  SCC in CO2: ", 
    round.(SCC_inCO2_15[1,:], digits=4), " USD | ", round(SCC_gall[1], digits=4), 
    " cents per gallon; ", round(SCC_lit[1], digits=4), " EUR-cents per liter; and ", 
    round.(SCC_inC[1,:], digits=4), " in C; rptp: ", round(param["rho"][1] * 100), "%")

    println("Inv rate ", round(1 - x[3], digits=3), " in 2020 IMF, SCC in CO2: ", 
    round.(SCC_inCO2_15[3,:], digits=4), " USD | ", round(SCC_gall[3], digits=4), 
    " cents per gallon; ", round(SCC_lit[3], digits=4), " EUR-cents per liter; and ", 
    round.(SCC_inC[3,:], digits=4), " in C; rptp: ",round(param["rho"][3] * 100), "%")

    println("    with M_t+1 forcing in T_t+1: ", round(beta_implied20 * SCC_inCO2_immediate_forc_tot[3,1], digits=4), 
    " USD | only phi_M carbon part: ", round(beta_implied20 * SCC_inCO2_immediate_forc[3,1], digits=4), " USD ")

    println("    with 1st step emission decay and M_t+1 forc T_t+1: SCC in CO2: ", 
    round(SCC_inCO2_15_edec[3,1], digits=4), " USD | more digits: ", 
    round(SCC_inCO2_15_edec[3,1], digits=10), " USD ")


    if population == 1
        println(" Including popuation weighting and UN population growth (until 2020 then stable) ")
        println("UN decadal growth 2020 until 2100 in %: ", round.(growth_pop_rate .* 100, digits=2))
        
        println(" Inv rate ", round.(1 - x_pop[1,1], digits=3), ";  rho exog,  SCC in CO2: ", 
                round.(SCC_inCO2_pop[1,:], digits=4), " USD | ", round.(SCC_gall_pop[1,:], digits=4), 
                " cents per gallon; ", round.(SCC_lit_pop[1,:], digits=4), " EUR-cents per liter; and ", 
                round.(SCC_inC_pop[1,:], digits=4), "  in C; rptp: ", round.(param["rho"][1] * 100), "%")
    
        println(" Inv rate ", round.(1 - x_pop[3,1], digits=3), " in 2020 IMF, SCC in CO2: ", 
               round.(SCC_inCO2_pop[3,:], digits=4), " USD | ", round.(SCC_gall_pop[3,:], digits=4), 
                " cents per gallon; ", round.(SCC_lit_pop[3,:], digits=4), " EUR-cents per liter; and ", 
                round.(SCC_inC_pop[3,:], digits=4), " in C; rptp: ", round.(param["rho"][3] * 100), "%")
    
        println("     SCC w/o temp delay for the 3 scenarios: ", round(SCC_inCO2_NoTempLag_pop[1,1], digits=3), 
                " USD/tCO2, ", round(SCC_inCO2_NoTempLag_pop[2,1], digits=3), " USD/tCO2, ", 
                round(SCC_inCO2_NoTempLag_pop[3,1], digits=3), " USD/tCO2")
    
    end
        
    end


end




